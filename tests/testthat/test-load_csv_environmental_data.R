# Instructions ----
#' This file follows the format generated by ecosystemdata:::use_testthat_template().
#' Necessary tests include input and output (IO) correctness [IO
#' correctness], edge-case handling [Edge handling], and built-in errors and
#' warnings [Error handling]. See `?ecosystemdata:::use_testthat_template` for more
#' information. Every test should have a @description tag that takes up just
#' one line, which will be used in the bookdown report of {testthat} results.

# Setup ----
# Load or prepare any necessary data for testing
# Read in amo data
amo_path <- fs::path(
  system.file("extdata", package = "ecosystemdata"),
  "ewe_nwatlantic", "environmental_link", "amo_lag1.csv"
)
amo_data <- read.csv(amo_path)

# Read in palmer_drought_severity_index.csv
pdsi_path <- fs::path(
  system.file("extdata", package = "ecosystemdata"),
  "ewe_nwatlantic", "environmental_link", "pdsi_lag0.csv"
)
pdsi_data <- read.csv(pdsi_path)

# load_csv_environmental_data ----
## IO correctness ----
test_that("load_csv_environmental_data() works with correct inputs", {
  object <- load_csv_environmental_data(
    file_path = amo_path,
    lag_months = 12,
    impacted_group = "menhaden 0"
  ) |>
    dplyr::bind_rows(
      load_csv_environmental_data(
        file_path = pdsi_path,
        lag_months = 0,
        impacted_group = "phytoplankton"
      )
    )

  #' @description Test that the function returns a tibble with the correct number of rows.
  expect_equal(
    object = nrow(object),
    expected = nrow(amo_data) + nrow(pdsi_data)
  )

  #' @description Test that the function returns correct snapshot.
  path <- tempfile(fileext = ".csv")
  write.csv(object, path, row.names = FALSE)
  on.exit(fs::file_delete(path))
  expect_snapshot_file(path, "load_csv_environmental_data.csv")

  #' @description Test that the function returns a tibble with expected column names.
  expect_equal(
    object = colnames(object),
    expected = c(
      "index", "year", "month", "value",
      "unit", "lag_months", "impacted_group",
      "species", "group"
    )
  )
})

## Edge handling ----
test_that("load_csv_environmental_data() returns correct outputs for edge cases", {
  amo_yearly_data <- amo_data |>
    # convert values from month 2 to 12 into NAs
    dplyr::mutate(value = ifelse(month == 1, value, NA)) 
  # write to a temporary file
  file_path <- fs::path(
    system.file("extdata", package = "ecosystemdata"),
    "ewe_nwatlantic", "environmental_link", "amo_yearly_data.csv"
  )
  write.csv(amo_yearly_data, file = file_path, row.names = FALSE)
  on.exit(fs::file_delete(file_path))

  #' @description Test that the function works with yearly data.
  expect_no_error(
    object = load_csv_environmental_data(
      file_path = file_path,
      lag_months = 12,
      impacted_group = "menhaden 0"
    )
  )
})

## Error handling ----
test_that("load_csv_environmental_data() returns correct error messages", {
  amo_missing_data <- amo_data |>
    dplyr::select(-c(month, unit))
  # write to a temporary file
  file_path <- fs::path(
    system.file("extdata", package = "ecosystemdata"),
    "ewe_nwatlantic", "environmental_link", "amo_missing_data.csv"
  )
  write.csv(amo_missing_data, file = file_path, row.names = FALSE)
  on.exit(fs::file_delete(file_path))

  #' @description Error when CSV file does not include required columns.
  expect_error(
    object = load_csv_environmental_data(
      file_path = file_path,
      lag_months = 12,
      impacted_group = "menhaden 0"
    ),
    regexp = 'The CSV file must contain the following columns.*month.*unit'
  )
})