# Instructions ----
#' This file follows the format generated by ecosystemdata:::use_testthat_template().
#' Necessary tests include input and output (IO) correctness [IO
#' correctness], edge-case handling [Edge handling], and built-in errors and
#' warnings [Error handling]. See `?ecosystemdata:::use_testthat_template` for more
#' information. Every test should have a @description tag that takes up just
#' one line, which will be used in the bookdown report of {testthat} results.

# Setup ----
# Load or prepare any necessary data for testing

# split_functional_groups ----
## IO correctness ----
test_that("split_functional_groups() works with correct inputs", {
  #' @description Test that split_functional_groups(x) returns a tibble.
  expect_equal(
    object = split_functional_groups(c("spiny dogfish0", "spiny dogfish 2")),
    expected = tibble::tibble(
      functional_group = c("spiny dogfish0", "spiny dogfish 2"),
      species = c("spiny dogfish", "spiny dogfish"),
      group = c("0", "2")
    )
  )

  #' @description Test that split_functional_groups(x), where the third row of
  #' x contains a `+` without any digits signifying a plus groups returns a
  #' row with + as the group.
  expect_equal(
    object = split_functional_groups(c(
      "spiny dogfish 0",
      "spiny dogfish 1-2",
      "spiny dogfish +",
      "apple"
    )),
    expected = tibble::tibble(
      functional_group = c(
        "spiny dogfish 0",
        "spiny dogfish 1-2",
        "spiny dogfish +",
        "apple"
      ),
      species = c(
        "spiny dogfish",
        "spiny dogfish",
        "spiny dogfish",
        "apple"
      ),
      group = c("0", "1-2", "+", NA_character_)
    )
  )
})

## Edge handling ----
test_that("split_functional_groups() returns correct outputs for edge cases", {
  input <- c("SpinyDogfish0", "SpinyDogfish 2_3")
  test <- split_functional_groups(input)
  #' @description Test that split_functional_groups(x) uses sentence case rather
  #' than camel case.
  expect_equal(
    object = test[["species"]],
    expected = c("Spiny Dogfish", "Spiny Dogfish")
  )
  #' @description Test that split_functional_groups(x) returns the input values
  #' in the `"functional_group"` column.
  expect_equal(
    object = test[["functional_group"]],
    expected = input
  )
})

## Error handling ----
test_that("split_functional_groups() returns correct error messages", {
  #' @description Test that split_functional_groups(x) returns expected error.
  expect_error(
    object = split_functional_groups(data.frame(functional_groups = "x")),
    regexp = "must be a character vector."
  )

  #' @description Test that split_functional_groups(x) requires input.
  expect_error(
    object = split_functional_groups(),
    regexp = "argument \"x\" is missing, with no default"
  )

  #' @description Test that non-numeric characters lead to an error but that
  #' a plus sign, a minus sign, or an underscore are okay. The dollar sign at
  #' the end of the regular expression ensures that the error message only
  #' contains the first functional group, which is the only bad one.
  expect_error(
    object = split_functional_groups(c("sdog#", "spiny+", "s_dog", "s-dog")),
    regexp = "`sdog#`$"
  )
  #' @description Test that you cannot have an ampersand.
  expect_error(
    object = split_functional_groups(c("spiny & dog")),
    regexp = "cannot contain non alpha-numerics except"
  )

  #' @description Test that split_functional_groups(x) requires an input vector.
  expect_error(
    split_functional_groups(),
    regexp = "argument \"x\" is missing, with no default"
  )
})
